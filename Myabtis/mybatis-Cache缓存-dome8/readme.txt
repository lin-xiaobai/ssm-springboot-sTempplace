cache缓存

MyBatis 内置了一个强大的事务性查询缓存机制

当查询操作的时候：连接数据库 ，每次连接数据库会消耗一些资源

缓存：将一次查询的结果，暂时存储在一个可以直接获取到的地方（不用通过数据库）---》内存

当再次查询相同的数据时候，直接走缓存，即直接从内存中获取，不用走数据库

缓存失效的情况：
1.查询不同的语句
2.增删改操作，可能会改变原来的数据，所以会刷新缓存 ，再次访问数据库
3.查询不同的Mapper.xml
4.手动清理缓存:: sqlSession.clearCache();

小结：一级缓存默认是开启的，只在一次sqlsession中有效，也就是拿到连接再关闭连接这个区间段


默认情况下，只启用了本地的会话缓存，它仅仅对一个会话中的数据进行缓存。
要启用全局的二级缓存，只需要在你的 SQL 映射文件中添加一行：
<cache/>
基本上就是这样。这个简单语句的效果如下:

映射语句文件中的所有 select 语句的结果将会被缓存。
映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。
缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存。
缓存不会定时进行刷新（也就是说，没有刷新间隔）。
缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。
缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。
提示 缓存只作用于 cache 标签所在的映射文件中的语句。如果你混合使用 Java API 和 XML 映射文件，在共用接口中的语句将不会被默认缓存。你需要使用 @CacheNamespaceRef 注解指定缓存作用域。

在对应的mapper.xml开启 二级缓存
1.二级缓存也叫全局缓存 ，一级缓存作用域太低了
2.基于namespeace级别的缓存，一个名称空间，对应一个二级缓存
工作机制
    1.一个会话查询一条语句，这个数据就被放在当前会话的一级缓存中
     2.如果当前会话关闭了，这个会话对应的一级缓存就没了，但是我们想要的是，会话关闭了，一级缓存中的数据被保存在二级缓存中
     3.新的会话查询信息，就可以从二级缓存中获取内容
     4.不同的mapper查初的数据会放在自己对应的缓存（map）中

1. <!--    开启二级缓存 即全局缓存-->使用标签<cache/>
    <cache/>
    2.在配置文件中设置 settings标签 添加setting标签<setting name="cacheEnabled" value="true"/>

这些属性可以通过 cache 元素的属性来修改。比如：

<cache
  eviction="FIFO"
  flushInterval="60000"
  size="512"
  readOnly="true"/>
  这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。

  可用的清除策略有：

  LRU – 最近最少使用：移除最长时间不被使用的对象。
  FIFO – 先进先出：按对象进入缓存的顺序来移除它们。
  SOFT – 软引用：基于垃圾回收器状态和软引用规则移除对象。
  WEAK – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。
  默认的清除策略是 LRU。


  一级缓存 存在sqlsession，当sqlsession关闭时，一级缓存的数据就会传到 mapper里的二级缓存中

  缓存顺序：
  1.先走二级缓存中看有没有查需要的数据
  二级缓存没有

  2.再看一级缓存中有没有
   一级缓存没有

  3.查询数据库